// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package queries

import (
	"context"
	"database/sql"
	"time"
)

const countBookmarks = `-- name: CountBookmarks :one
SELECT
  COUNT(ID)
FROM
  bookmarks
WHERE
  user_id = ?
`

func (q *Queries) CountBookmarks(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countBookmarks, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteAllBookmarks = `-- name: DeleteAllBookmarks :exec
DELETE FROM bookmarks
`

func (q *Queries) DeleteAllBookmarks(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteAllBookmarks)
	return err
}

const deleteBookmark = `-- name: DeleteBookmark :exec
DELETE FROM bookmarks
WHERE
  id = ?
`

func (q *Queries) DeleteBookmark(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteBookmark, id)
	return err
}

const getBookmark = `-- name: GetBookmark :one
SELECT
  id, author_id, channel_id, content, created_at, due_at, guild_id, message_id, timestamp, updated_at, user_id
FROM
  bookmarks
WHERE
  id = ?
LIMIT
  1
`

func (q *Queries) GetBookmark(ctx context.Context, id int64) (Bookmark, error) {
	row := q.db.QueryRowContext(ctx, getBookmark, id)
	var i Bookmark
	err := row.Scan(
		&i.ID,
		&i.AuthorID,
		&i.ChannelID,
		&i.Content,
		&i.CreatedAt,
		&i.DueAt,
		&i.GuildID,
		&i.MessageID,
		&i.Timestamp,
		&i.UpdatedAt,
		&i.UserID,
	)
	return i, err
}

const listBookmarksForUser = `-- name: ListBookmarksForUser :many
SELECT
  id, author_id, channel_id, content, created_at, due_at, guild_id, message_id, timestamp, updated_at, user_id
FROM
  bookmarks
WHERE
  user_id = ?
ORDER BY
  guild_id, channel_id, timestamp
`

func (q *Queries) ListBookmarksForUser(ctx context.Context, userID string) ([]Bookmark, error) {
	rows, err := q.db.QueryContext(ctx, listBookmarksForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Bookmark
	for rows.Next() {
		var i Bookmark
		if err := rows.Scan(
			&i.ID,
			&i.AuthorID,
			&i.ChannelID,
			&i.Content,
			&i.CreatedAt,
			&i.DueAt,
			&i.GuildID,
			&i.MessageID,
			&i.Timestamp,
			&i.UpdatedAt,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDueBookmarks = `-- name: ListDueBookmarks :many
SELECT
  id, author_id, channel_id, content, created_at, due_at, guild_id, message_id, timestamp, updated_at, user_id
FROM
  bookmarks
WHERE
  due_at IS NOT NULL
  AND due_at < ?1
`

func (q *Queries) ListDueBookmarks(ctx context.Context, now sql.NullTime) ([]Bookmark, error) {
	rows, err := q.db.QueryContext(ctx, listDueBookmarks, now)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Bookmark
	for rows.Next() {
		var i Bookmark
		if err := rows.Scan(
			&i.ID,
			&i.AuthorID,
			&i.ChannelID,
			&i.Content,
			&i.CreatedAt,
			&i.DueAt,
			&i.GuildID,
			&i.MessageID,
			&i.Timestamp,
			&i.UpdatedAt,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBookmarkDueAt = `-- name: UpdateBookmarkDueAt :exec
Update bookmarks
SET
  due_at = ?
WHERE
  id = ?
`

type UpdateBookmarkDueAtParams struct {
	DueAt sql.NullTime
	ID    int64
}

func (q *Queries) UpdateBookmarkDueAt(ctx context.Context, arg UpdateBookmarkDueAtParams) error {
	_, err := q.db.ExecContext(ctx, updateBookmarkDueAt, arg.DueAt, arg.ID)
	return err
}

const updateOrCreateBookmark = `-- name: UpdateOrCreateBookmark :execlastid
INSERT INTO
  bookmarks (
    author_id,
    channel_id,
    content,
    created_at,
    due_at,
    guild_id,
    message_id,
    timestamp,
    updated_at,
    user_id
  )
VALUES
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT (channel_id, guild_id, message_id, user_id) DO UPDATE
SET
  created_at = ?4,
  due_at = ?5,
  updated_at = ?9
`

type UpdateOrCreateBookmarkParams struct {
	AuthorID  string
	ChannelID string
	Content   string
	CreatedAt time.Time
	DueAt     sql.NullTime
	GuildID   string
	MessageID string
	Timestamp time.Time
	UpdatedAt time.Time
	UserID    string
}

func (q *Queries) UpdateOrCreateBookmark(ctx context.Context, arg UpdateOrCreateBookmarkParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateOrCreateBookmark,
		arg.AuthorID,
		arg.ChannelID,
		arg.Content,
		arg.CreatedAt,
		arg.DueAt,
		arg.GuildID,
		arg.MessageID,
		arg.Timestamp,
		arg.UpdatedAt,
		arg.UserID,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}
